import { shallowMount, flushPromises } from '@vue/test-utils';
import { nextTick } from 'vue';
import VulnerabilityTableSet from '../VulnerabilityTableSet.vue';

describe('VulnerabilityTableSet.vue', () => {
  let wrapper: any;

  beforeEach(async() => {
    wrapper = shallowMount(VulnerabilityTableSet, {
      global: {
        mocks: {
          $fetchState: { pending: false },
          $route:      { params: { id: 'test-image-route', cluster: 'test-cluster' } },
        },
        stubs: { RouterLink: { template: '<a><slot /></a>', props: ['to'] } }
      },
      props: {
        vulnerabilityDetails: [{ id: 1 }],
        severity:             'Critical',
      },
    });

    await flushPromises();
  });

  it('initializes default data correctly', () => {
    const data = wrapper.vm.$data;

    expect(data.filters.cveSearch).toBe('');
    expect(data.filters.fixAvailable).toBe('any');
    expect(data.cachedFilteredVulnerabilities).toEqual([]);
  });

  it('updates cachedFilteredVulnerabilities when filters are applied', async() => {
    Object.defineProperty(wrapper.vm, 'vulnerabilityDetails', {
      get: () => [
        {
          cveId:          'CVE-2025-0001',
          score:          '9.8 (CVSS v3)',
          package:        'openssl',
          fixAvailable:   true,
          severity:       'high',
          exploitability: 'Affected',
        },
        {
          cveId:          'CVE-2025-0002',
          score:          '4.2 (CVSS v3)',
          package:        'bash',
          fixAvailable:   false,
          severity:       'low',
          exploitability: 'Suppressed',
        },
      ],
    });

    wrapper.vm.filters = {
      cveSearch:      '0001',
      scoreMin:       '5',
      scoreMax:       '9.9',
      fixAvailable:   'any',
      severity:       'any',
      exploitability: 'any',
      packageSearch:  'ssl',
    };

    wrapper.vm.updateFilteredVulnerabilities();
    await nextTick();

    expect(wrapper.vm.cachedFilteredVulnerabilities).toHaveLength(1);
    expect(wrapper.vm.cachedFilteredVulnerabilities[0].cveId).toBe('CVE-2025-0001');
  });

  it('updates cachedFilteredVulnerabilities when filters are applied - fixAvailable, severity, exploitability are not any', async() => {
    Object.defineProperty(wrapper.vm, 'vulnerabilityDetails', {
      get: () => [
        {
          cveId:          'CVE-2025-0001',
          score:          '9.8 (CVSS v3)',
          package:        'openssl',
          fixAvailable:   true,
          severity:       'high',
          exploitability: 'Affected',
        },
        {
          cveId:          'CVE-2025-0002',
          score:          '4.2 (CVSS v3)',
          package:        'bash',
          fixAvailable:   false,
          severity:       'low',
          exploitability: 'Suppressed',
        },
      ],
    });

    wrapper.vm.filters = {
      cveSearch:      '',
      scoreMin:       '',
      scoreMax:       '',
      fixAvailable:   'available',
      severity:       'high',
      exploitability: 'affected',
      packageSearch:  '',
    };

    wrapper.vm.updateFilteredVulnerabilities();
    await nextTick();

    expect(wrapper.vm.cachedFilteredVulnerabilities).toHaveLength(1);
    expect(wrapper.vm.cachedFilteredVulnerabilities[0].cveId).toBe('CVE-2025-0001');
  });

  it('filters by severity via filterBySeverity method', () => {
    wrapper.vm.filterBySeverity();
    expect(wrapper.vm.filters.severity).toBe('Critical');
  });

  it('resets selectedVulnerabilities when vulnerabilityDetails length changes', async() => {

    const wrapper = shallowMount(VulnerabilityTableSet, { propsData: { vulnerabilityDetails: [{ id: 1 }, { id: 2 }] } });

    // Pretend the user selected some vulnerabilities
    wrapper.vm.selectedVulnerabilities = [{ id: 1 }];

    // Spy on updateFilteredVulnerabilities
    const spy = jest.spyOn(wrapper.vm, 'updateFilteredVulnerabilities');

    // Trigger watcher by changing props
    await wrapper.setProps({ vulnerabilityDetails: [{ id: 1 }] // length changed 2 -> 1
    });

    await flushPromises();

    // Expect selection reset
    expect(wrapper.vm.selectedVulnerabilities).toEqual([]);

    // Watcher should trigger this method
    expect(spy).toHaveBeenCalled();
  });


  it('does NOT reset selection if length stays the same', async() => {
    const wrapper = shallowMount(VulnerabilityTableSet, { propsData: { vulnerabilityDetails: [{ id: 1 }, { id: 2 }] } });

    wrapper.vm.selectedVulnerabilities = [{ id: 1 }];

    await wrapper.setProps({ vulnerabilityDetails: [{ id: 1 }, { id: 3 }] // length same (2)
    });

    await flushPromises();

    // Selection should NOT reset
    expect(wrapper.vm.selectedVulnerabilities).toEqual([{ id: 1 }]);
  });
});
