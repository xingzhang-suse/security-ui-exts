<template>
  <div class="page">
    <div class="header-section">
      <div class="title">
        {{ t("imageScanner.images.title") }}
      </div>
      <div class="filter-dropdown">
        <LabeledSelect
          v-model:value="selectedCveFilter"
          :options="filterCveOptions"
          :close-on-select="true"
          :multiple="false"
          @selecting="changeCveFilter"
        />
      </div>
      <div class="filter-dropdown">
        <LabeledSelect
          v-model:value="selectedImageFilter"
          :options="filterImageOptions"
          :close-on-select="true"
          :multiple="false"
          @selecting="changeImageFilter"
        />
      </div>
      <div>
        <button
          mat-button
          class="btn role-primary"
          aria-label="Download full report"
          type="button"
          :disabled="disabled"
          @click="openAddEditRuleModal()">
          <i class="icon icon-download"></i>
          {{ t('imageScanner.images.downloadReport') }}
        </button>
      </div>
    </div>
    <div class="summary-section">
      <TopRiskyImagesChart v-if="preprocessedDataset.topRiskyImages" :topRiskyImages="preprocessedDataset.topRiskyImages"/>
      <ImageRiskAssessment v-if="preprocessedDataset.chartData" :chartData="preprocessedDataset.chartData" :filterFn="filterBySeverity"/>
    </div>
    <SortableTable
      :has-advanced-filtering="false"
      :namespaced="false"
      :row-actions="false"
      :table-actions="true"
      :force-update-live-and-delayed="0"
      :use-query-params-for-simple-filtering="true"
      :sub-expandable="isGrouped"
      :sub-rows="isGrouped"
      :sub-expand-column="isGrouped"
      :rows="isGrouped ? preprocessedDataset.rowsByRepo : preprocessedDataset.preprocessedImages"
      :headers="isGrouped ? REPO_BASED_TABLE : IMAGE_LIST_TABLE"
      :key-field="'id'"
      @selection="onSelectionChange"
    >
      <template #header-left>
        <div class="table-top-left">
          <DownloadCustomReport
            class="table-btn" 
            :selectedRows="selectedRows"
            :buttonName="t('imageScanner.images.buttons.downloadCustomReport')"
          />
        </div>
      </template>
      <template #header-right>
        <div class="table-top-right">
          <Checkbox 
            style="margin-top: 8px; width: 180px;"
            label-key="imageScanner.images.listTable.checkbox.groupByRepo"
            v-model:value="isGrouped"
            @update:value="updateData($event)"
          />
        </div>
      </template>
      <template v-if="isGrouped" #sub-row="{ row, fullColspan }">
        <tr
          class="sub-row"
        >
          <td :colspan="fullColspan">
            <SortableTable
              class="sub-table"
              :rows="row.images"
              :headers="REPO_BASED_IMAGE_LIST_TABLE"
              :search="false"
              :row-actions="false"
              :table-actions="false"
            />
          </td>
        </tr>
      </template>
    </SortableTable>
  </div>


</template>

<script>
  import SortableTable from "@shell/components/SortableTable";
  import LabeledSelect from "@shell/components/form/LabeledSelect";
  import DownloadCustomReport from "@pkg/components/common/DownloadCustomReport";
  import TopRiskyImagesChart from "@pkg/components/TopRiskyImagesChart";
  import ImageRiskAssessment from "@pkg/components/ImageRiskAssessment"
  import { images } from "@pkg/data/sbombastic.rancher.io.image";
  import { IMAGE_LIST_TABLE, REPO_BASED_TABLE, REPO_BASED_IMAGE_LIST_TABLE } from "@pkg/config/table-headers";
  import { Checkbox } from '@components/Form/Checkbox';
import { filter } from "lodash";
  export default {
    name: 'imageOverview',
    components: {
      LabeledSelect,
      TopRiskyImagesChart,
      ImageRiskAssessment,
      SortableTable,
      DownloadCustomReport,
      Checkbox,
    },
    data() {
      const filterCveOptions = [
        {
          value: "allCves",
          label: this.t('imageScanner.images.filters.cve.allCves')
        },
        {
          value: "affectingCvesOnly",
          label: this.t('imageScanner.images.filters.cve.affectingCvesOnly')
        },
      ];
      const filterImageOptions = [
        {
          value: "allImages",
          label: this.t('imageScanner.images.filters.image.allImages')
        },
        {
          value: "excludeBaseImages",
          label: this.t('imageScanner.images.filters.image.excludeBaseImages')
        },
        {
          value: "includeBaseImages",
          label: this.t('imageScanner.images.filters.image.includeBaseImages')
        }
      ];
      return {
        rows: images,
        REPO_BASED_TABLE: REPO_BASED_TABLE,
        IMAGE_LIST_TABLE: IMAGE_LIST_TABLE,
        REPO_BASED_IMAGE_LIST_TABLE: REPO_BASED_IMAGE_LIST_TABLE,
        isGrouped: false,
        selectedRows: [],
        preprocessedDataset: {},
        preprocessedImagesBak: [],
        filterCveOptions,
        filterImageOptions,
        selectedCveFilter: filterCveOptions[0],
        selectedImageFilter: filterImageOptions[0],
        selectedImage: "",
        selectedSeverity: "",
        selectedRepository: "Any",
        selectedRegistry: "Any",
      }
    },

    async fetch() {
      this.preprocessedDataset = this.preprocessData(this.rows);
      this.preprocessedImagesBak = _.cloneDeep(this.preprocessedDataset.preprocessedImages);
      console.log("this.preprocessedDataset", this.preprocessedDataset)
    },

    methods: {
      applyFilters() {
        let filtered = _.cloneDeep(this.preprocessedImagesBak);
        if (this.selectedImageFilter.value === "excludeBaseImages" || this.selectedImageFilter === "excludeBaseImages") {
          filtered = filtered.filter(image => !image.spec.isBaseImage);
        } else if (this.selectedImageFilter.value === "includeBaseImages" || this.selectedImageFilter === "includeBaseImages") {
          filtered = filtered.filter(image => image.spec.isBaseImage);
        }
        if (this.selectedCveFilter.value === "affectingCvesOnly" || this.selectedCveFilter === "affectingCvesOnly") {
          filtered = filtered.filter(image => image.spec.hasAffectedPackages);
        }
        this.preprocessedDataset = this.preprocessData(filtered);
      },

      changeImageFilter(selectedImageFilter) {
        this.selectedImageFilter = selectedImageFilter;
        this.applyFilters();
      },

      changeCveFilter(selectedCveFilter) {
        this.selectedCveFilter = selectedCveFilter;
        this.applyFilters();
      },
      filterBySeverity(severity) {
        this.preprocessedDataset.preprocessedImages = _.cloneDeep(this.preprocessedImagesBak);
        if (severity) {
          this.preprocessedDataset.preprocessedImages = this.preprocessedDataset.preprocessedImages.filter(image => (image.severity.toLowerCase() === severity.toLowerCase()));
        }
      },
      onSelectionChange(selected) {
        this.selectedRows = selected || [];
      },
      preprocessData(images) {
        console.log("images", images);
        const severityKeys = ['critical', 'high', 'medium', 'low', 'none'];
        const chartData = {};
        const repoMap = new Map();
        const preprocessedImages = [];

        for (const key of severityKeys) {
          chartData[key] = 0;
        }

        const topRiskyImages = images.map(image => {
          let repoRec = {};
          let imageSeverity = "";
          const mapKey = `${image.spec.repository},${image.spec.registry}`;
          const currImageScanResult = {};
          for (const key of severityKeys) {
            currImageScanResult[key] = image.spec.scanResult[key];
            if (!imageSeverity) {
              imageSeverity = (image.spec.scanResult[key] || 0) > 0 ? key : "";
            }
          }
          if (repoMap.has(mapKey)) {
            const currRepo = repoMap.get(mapKey);
            for (const key of severityKeys) {
              currRepo.cveCntByRepo[key] += image.spec.scanResult[key];
            }
            currRepo.images.push(
              {
                metadata: { name: image.metadata.name },
                scanResult: currImageScanResult,
              }
            );
            repoMap.set(mapKey, currRepo);
          } else {
            repoRec = {
              id: mapKey,
              repository: image.spec.repository,
              registry: image.spec.registry,
              cveCntByRepo: currImageScanResult,
              images: [
                {
                  metadata: { name: image.metadata.name} ,
                  scanResult: currImageScanResult,
                }
              ]
            }
            repoMap.set(mapKey, repoRec);
          }
          for (const key of severityKeys) {
            chartData[key] += imageSeverity === key ? 1 : 0;
          }
          preprocessedImages.push({
            ...image,
            severity: imageSeverity || "none",
          });
          return {
            imageName: image.metadata.name,
            cveCnt: image.spec.scanResult,
          }
        }).sort((a, b) => {
          for (const key of severityKeys) {
            const diff = (b.cveCnt[key] || 0) - (a.cveCnt[key] || 0);
            if (diff !== 0) return diff;
          }
          return 0;
        }).slice(0, 5);
        return {
          preprocessedImages,
          topRiskyImages,
          chartData,
          rowsByRepo: Array.from(repoMap.values())
        };
      },
      updateData(event) {
        console.log("isGrouped", this.isGrouped);
      },
    },

    computed: {
    },
  }

</script>


<style scoped>
  .page {
    display: flex;
    flex-direction: column;
    padding: 20px;
    min-height: 100%;
  }
  .header-section {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    align-self: stretch;
    border-radius: 6px;
    .title {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
      color: #141419;
      font-family: Lato;
      font-size: 24px;
      font-style: normal;
      font-weight: 600;
      line-height: 32px; /* 133.333% */
    }
    .filter-dropdown {
      display: flex;
      width: 225px;
      height: 40px;
    }
  }
  .summary-section {
    display: flex;
    align-items: flex-start;
    align-self: stretch;
    border-radius: 6px;
    border: 1px solid #DCDEE7;
    background: #FFF;
    margin: 24px 0;
  }
  .table-filter-section {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    align-self: stretch;
    .table-filter {
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
      .title {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        align-self: stretch;
        overflow: hidden;
        color: #6C6C76;
        text-overflow: ellipsis;
        font-family: Lato;
        font-size: 14px;
        font-style: normal;
        font-weight: 400;
        line-height: 21px; /* 150% */
      }
    }
  }

</style>