<template>
  <div class="page">
    <div class="header-section">
      <div class="header-left">
        <div class="title-wrap">
          <div class="title">{{ t('imageScanner.registries.title') }}</div>
        </div>
        <div class="state">State as of <span class="state-date-time">{{ latestUpdateTimeText }}</span></div>
      </div>
      <div class="header-right">
        <div class="header-btn">
          <button
            mat-button
            class="btn role-secondary"
            aria-label="Refresh data"
            type="button"
            :disabled="disabled"
            @click="refresh()">
            <em class="icon-refresh-ss"></em>{{ t('imageScanner.registries.button.refresh') }}
          </button>
        </div>
        <div class="header-btn">
          <button
            mat-button
            class="btn role-primary"
            aria-label="Add new"
            type="button"
            :disabled="disabled"
            @click="openAddEditRegistry()">
            {{ t('imageScanner.registries.button.addNew') }}
          </button>
        </div>
      </div>
    </div>
    <div class="summary-section">
      <RecentUpdatedRegistries :registryStatusList="registryStatusList"/>
      <StatusDistribution :filterFn="filterByStatus" :chartData="statusSummary"/>
    </div>
    <SortableTable
      ref="table"
      :has-advanced-filtering="false"
      :namespaced="false"
      :row-actions="true"
      :table-actions="true"
      :force-update-live-and-delayed="0"
      :use-query-params-for-simple-filtering="true"
      :rows="rows"
      :headers="headers"
      :key-field="'id'"
      @selection="onSelectionChange"
    >
      <template #header-left>
          <div class="table-top-left">
            <ScanButton class="table-btn" :selectedRegistries="selectedRows?.map(row => {return {name: row.metadata.name, namespace: row.metadata.namespace, currStatus: row.currStatus}})" :reloadFn="loadData" />
            <button
              class="btn role-primary table-btn"
              :disabled="!(selectedRows && selectedRows.length)"
              @click="promptRemoveRegistry()"
            >
              <i class="icon icon-delete"></i>
              {{ t('imageScanner.registries.button.delete') || 'Delete' }}
            </button>
          </div>
      </template>
    </SortableTable>
  </div>
</template>

<script>

  import { ref } from "vue";
  import { RESOURCE } from "@pkg/types";
  import SortableTable from "@shell/components/SortableTable";
  import RecentUpdatedRegistries from "@pkg/components/RecentUpdatedRegistries";
  import StatusDistribution from "@pkg/components/StatusDistribution";
  import { REGISTRY_SCAN_TABLE } from "@pkg/config/table-headers";
  import {
    PRODUCT_NAME,
  } from "@pkg/types";
  import { escapeHtml } from '@shell/utils/string';
  import day from 'dayjs';
  import { DATE_FORMAT, TIME_FORMAT } from '@shell/store/prefs';
  import { findBy } from '@shell/utils/array';
  import ScanButton from "@pkg/components/common/ScanButton";
  
  export default {
    name: 'registries',
    components: {
      SortableTable,
      RecentUpdatedRegistries,
      StatusDistribution,
      ScanButton,
    },
    data() {
      return {
        content: ref("Registries"),
        PRODUCT_NAME: PRODUCT_NAME,
        rows: [],
        registryStatusList: [],
        latestUpdateTime: null,
        statusSummary: {},
        headers: REGISTRY_SCAN_TABLE,
      }
    },

    async fetch() {
      await this.loadData();
    },
    methods: {
      async loadData(isForceLoading = false) {
        await this.$store.dispatch('cluster/findAll', { type: RESOURCE.REGISTRY, opt: {force: isForceLoading} });
        if (this.$store.getters['cluster/canList'](RESOURCE.SCAN_JOB)) {
          await this.$store.dispatch('cluster/findAll', { type: RESOURCE.SCAN_JOB, opt: {force: isForceLoading} });
        }
        this.registryStatusList = [];
        this.statusSummary = {};
        
        let registriesCRD = this.$store.getters['cluster/all'](RESOURCE.REGISTRY);

        //Fetch ScanJob CRD and sort by startTime DESC
        let scanJobCRD = this.$store.getters['cluster/all'](RESOURCE.SCAN_JOB).sort((a, b) => {
          if (!a.status || !a.status.conditions || !Array.isArray(a.status.conditions) || a.status.conditions.length === 0) {
            return 1;
          }
          if (!b.status || !b.status.conditions || !Array.isArray(b.status.conditions)  || b.status.conditions.length === 0) {
            return -1;
          }
          return this.getLastTransitionTime(b.status.conditions) - this.getLastTransitionTime(a.status.conditions);
        });

        const scanJobMap = this.getScanJobMap(scanJobCRD);
        const registryDataset  = this.getRegistryDataset(registriesCRD, scanJobMap);
        this.rows = registryDataset.rows;
        this.registryStatusList = registryDataset.registryStatusList;
        this.statusSummary = registryDataset.statusSummary;
      },
      refresh() {
        this.loadData(true);
      },
      filterByStatus(status) {
        const el = document.querySelector(
          'input[type="search"][placeholder="Filter"][aria-label="Filter table results"]'
        );
        el.value = status;

        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new KeyboardEvent('keyup', { bubbles: true, key: 'a' }));
      },
      openAddEditRegistry() {
        this.$router.push({
          name: `${ PRODUCT_NAME }-c-cluster-resource-create`,
          params: {
            resource: RESOURCE.REGISTRY,
            cluster: this.$route.params.cluster,
            product: PRODUCT_NAME
          }
        });
      },
      onSelectionChange(selected) {
        this.selectedRows = selected || [];
      },
      async promptRemoveRegistry() {
        const table = this.$refs.table;
        const act = findBy(table.availableActions, 'action', 'promptRemove');
        if ( act ) {
          table.setBulkActionOfInterest(act);
          table.applyTableAction(act);
        }
        return;
      },
      getScanJobMap(scanJobCRD) {
        let scanJobMap = {};
        scanJobCRD.forEach((rec) => {
          // Calculate statusResult
          
          if (!rec.status) {// A extreme corner case, the scanner created a job without status object
            rec.status = {
              statusResult: {
                type: "Pending",
                lastTransitionTime: null,
                statusIndex: -1
              }
            };
          }
          let statusIndex = rec.status.conditions?.findIndex((condition) => {
            return condition.status === "True";
          });
          rec.status.statusResult = statusIndex > -1 ? {
            type: rec.status.conditions[statusIndex].type,
            lastTransitionTime: rec.status.conditions[statusIndex].lastTransitionTime,
            message: rec.status.conditions[statusIndex].message,
            statusIndex: statusIndex
          } : {
            type: "Pending",
            lastTransitionTime: null,
            statusIndex: -1
          };

          // Set ScanJobe map with namespace/registry as key and up to 2 scan jobs as value
          if (
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`] &&
            Array.isArray(scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`]) &&
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`].length > 0 &&
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`].length < 2) {
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`].push(rec);
          } else if (!scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`]) {
            scanJobMap[`${rec.metadata.namespace}/${rec.spec.registry}`] = [rec];
          }
        });
        return scanJobMap;
      },
      getRegistryDataset(registriesCRD, scanJobMap ) {
        let registryStatusList = [];
        const statusSummary = {
          pending: 0,
          scheduled: 0,
          inprogress: 0,
          complete: 0,
          failed: 0
        };
        const rows = registriesCRD;
        registriesCRD.forEach((rec, index) => {
          this.latestUpdateTime = new Date();
          let scanjobs = scanJobMap[`${rec.metadata.namespace}/${rec.metadata.name}`] || [];
          const status = scanjobs[0] ? scanjobs[0].status.statusResult.type.toLowerCase() || "pending" : "none";
          const prevStatus = this.getPreviousStatus(scanjobs);
          const prevScanStatus = scanjobs[1] ? scanjobs[1].status.statusResult.type.toLowerCase() || "pending" : "none";
          
          // Reform the record for the table
          rows[index].currStatus = status;
          rows[index].prevScanStatus = prevScanStatus;
          rows[index].progress = scanjobs[0] && scanjobs[0].status.imagesCount && scanjobs[0].status.scannedImagesCount?
            Math.ceil(scanjobs[0].status.scannedImagesCount / scanjobs[0].status.imagesCount * 100) : 0;
          rows[index].progressDetail = `${this.t("imageScanner.registries.configuration.scanTable.header.imagesScanned")}: ${scanjobs[0] ? scanjobs[0].status.scannedImagesCount : 0} / ${this.t("imageScanner.registries.configuration.scanTable.header.imagesFound")}: ${scanjobs[0] ? scanjobs[0].status.imagesCount : 0}`;
          rows[index].prevProgress = scanjobs[1] && scanjobs[1].status.imagesCount && scanjobs[1].status.scannedImagesCount?
            Math.ceil(scanjobs[1].status.scannedImagesCount / scanjobs[1].status.imagesCount * 100) : 0;
          rows[index].prevProgressDetail = `${this.t("imageScanner.registries.configuration.scanTable.header.imagesScanned")}: ${scanjobs[1] ? scanjobs[1].status.scannedImagesCount : 0} / ${this.t("imageScanner.registries.configuration.scanTable.header.imagesFound")}: ${scanjobs[1] ? scanjobs[1].status.imagesCount : 0}`;
          rows[index].error = scanjobs[0] && scanjobs[0].status.statusResult.type.toLowerCase() === "failed" ? scanjobs[0].status.statusResult.message : "";
          rows[index].prevError = scanjobs[1] && scanjobs[1].status.statusResult.type.toLowerCase() === "failed" ? scanjobs[1].status.statusResult.message : "";
          rows[index].refreshFn = this.refresh;

          // Summarize the data for Latest status updates panel
          registryStatusList.push({
            registryName: rec.metadata.name,
            uri: rec.spec.uri,
            namespace: rec.metadata.namespace,
            prevScanStatus: prevStatus,
            currStatus: status,
            lastTransitionTime: scanjobs[0]?.status?.statusResult?.lastTransitionTime || rec.metadata.creationTimestamp,
          });

          //Summarize the data for Status distribution panel
          if (status && statusSummary.hasOwnProperty(status)) {
            statusSummary[status]++;
          }
        });
        // Sort and limit the registryStatusList to 5 most recent updates
        registryStatusList = registryStatusList.sort((a, b) => new Date(b.lastTransitionTime) - new Date(a.lastTransitionTime)).slice(0, 5);
        while (registryStatusList.length < 5) {
          registryStatusList.push({
            registryName: "",
            uri: "",
            prevScanStatus: "",
            currStatus: "",
            lastTransitionTime: new Date().toISOString()
          });
        }

        console.log("rows", rows)
        return {
          rows,
          registryStatusList,
          statusSummary
        }
      },
      getPreviousStatus(scanjobs) {
        if (scanjobs && scanjobs[0] && scanjobs[0].status && scanjobs[0].status.statusResult && scanjobs[0].status.statusResult.statusIndex > 0) {
          let index = scanjobs[0].status.statusResult.statusIndex;
          if (index < 3) {
            return scanjobs[0].status.conditions[index - 1].type.toLowerCase();
          } else {
            return scanjobs[0].status.conditions[index - 2].type.toLowerCase();
          }
        } else if (scanjobs && scanjobs[1]) {
          return scanjobs[1].status.statusResult.type.toLowerCase();
        } else {
          return "none";
        }
      },
      getLastTransitionTime(conditions) {
        let lastTransitionTime = 0;
        conditions.forEach(condition => {
          lastTransitionTime = Math.max(lastTransitionTime, new Date(condition.lastTransitionTime).getTime())
        })
        return lastTransitionTime;
      },
    },
    computed: {
      schema() {
        return this.$store.getters['cluster/schemaFor'](RESOURCE.REGISTRY);
      },
      latestUpdateTimeText() {
        const dateFormat = escapeHtml( this.$store.getters['prefs/get'](DATE_FORMAT));
        const timeFormat = escapeHtml( this.$store.getters['prefs/get'](TIME_FORMAT));
        return `${day(new Date(this.latestUpdateTime).getTime()).format(dateFormat)} ${day(new Date(this.latestUpdateTime).getTime()).format(timeFormat)}`;
      },
    },
  }

</script>


<style lang="scss" scoped>
  .page {
    display: flex;
    flex-direction: column;
    padding: 24px;
    min-height: 100%;
  }
  .header-section {
    display: flex;
    align-items: flex-start;
    gap: 24px;
    align-self: stretch;
    margin-bottom: 24px;
    
  }
  .table-top-left {
      display: flex;
      align-items: start-end;
      justify-content: start;
      flex: 1 0 0;
      gap: 16px;
    .table-btn {
      height: 40px;
    }
  }
  .header-left {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      flex: 1 0 0;
    }
    .title-wrap {
      display: flex;
      align-items: center;
      gap: 12px;
      align-self: stretch;
      .title {
        color: #141419;
        font-family: Lato;
        font-size: 24px;
        font-style: normal;
        font-weight: 400;
        line-height: 32px; /* 133.333% */
      }
      .state {
        display: -webkit-box;
        max-width: 900px;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        line-clamp: 1;
        align-self: stretch;
        overflow: hidden;
        color: #717179;

        text-overflow: ellipsis;
        font-family: Lato;
        font-size: 14px;
        font-style: normal;
        font-weight: 400;
        line-height: 21px; /* 150% */

        .state-date-time {
          overflow: hidden;
          -webkit-box-orient: vertical;
          line-clamp: 1;
          color: #717179;
          text-overflow: ellipsis;
          font-family: Lato;
          font-size: 14px;
          font-style: normal;
          font-weight: 400;
          line-height: 21px;
        }
      }
    }
    .header-right {
      display: flex;
      align-items: flex-end;
      justify-content: end;
      flex: 1 0 0;
      gap: 16px;
    }
    .header-btn {
      height: 40px;
    }
    .icon-add {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      background: url('../../../../assets/img/add.svg') no-repeat center center;
      background-size: contain;
    }
    .icon-refresh-ss {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      background: url('../../../../assets/img/refresh.svg') no-repeat center center;
      background-size: contain;
    }
  .summary-section {
    display: flex;
    min-width: 912px;
    align-items: flex-start;
    align-self: stretch;
    border-radius: 6px;
    border: 1px solid #DCDEE7;
    background: #FFF;
    margin: 24px 0;
  }
   
</style>